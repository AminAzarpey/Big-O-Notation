مفهوم **O(n)** یا **Big O Notation** در جاوااسکریپت (و به طور کلی در علوم کامپیوتر) برای توصیف پیچیدگی زمانی یا فضایی الگوریتم‌ها استفاده می‌شه. پیچیدگی زمانی نشون می‌ده که یه الگوریتم با افزایش اندازه ورودی (n) چقدر زمان یا منابع نیاز داره. در اینجا چند نوع رایج پیچیدگی زمانی رو با مثال‌های ساده در جاوااسکریپت توضیح می‌دم و بهت یاد می‌دم که چطور بتونی این مفهوم رو درک کنی.

### 1. **O(1) - پیچیدگی ثابت (Constant Time)**
- **توضیح**: مهم نیست ورودی چقدر بزرگ باشه، زمان اجرا ثابت می‌مونه.
- **مثال**: دسترسی به یه عنصر خاص در آرایه.
```javascript
function getFirstElement(arr) {
  return arr[0]; // همیشه یه عملیات انجام می‌شه
}
```
- **چرا O(1)؟** چون دسترسی به اندیس صفرم آرایه همیشه یه عملیاته، چه آرایه 10 عنصر داشته باشه، چه 10 میلیون.
- **کاربرد**: دسترسی به عناصر آرایه یا شیء با کلید خاص، عملیات‌های ساده مثل محاسبات ریاضی.

### 2. **O(n) - پیچیدگی خطی (Linear Time)**
- **توضیح**: زمان اجرا با اندازه ورودی به صورت خطی افزایش پیدا می‌کنه. اگه n دو برابر بشه، زمان اجرا هم تقریباً دو برابر می‌شه.
- **مثال**: جستجوی خطی (Linear Search) در یه آرایه.
```javascript
function findElement(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i; // اگه پیدا کرد، اندیس رو برمی‌گردونه
  }
  return -1; // اگه پیدا نکرد
}
```
- **چرا O(n)؟** در بدترین حالت، باید کل آرایه (n عنصر) رو بررسی کنیم.
- **کاربرد**: حلقه‌های ساده که هر عنصر ورودی رو یه بار بررسی می‌کنن، مثل پیدا کردن یه مقدار در آرایه.

### 3. **O(n²) - پیچیدگی درجه دوم (Quadratic Time)**
- **توضیح**: زمان اجرا با مربع اندازه ورودی افزایش پیدا می‌کنه. برای ورودی‌های بزرگ خیلی کند می‌شه.
- **مثال**: مرتب‌سازی حبابی (Bubble Sort).
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // جابه‌جایی
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```
- **چرا O(n²)؟** برای هر عنصر (n)، باید بقیه عناصر (تقریباً n) رو بررسی کنیم، پس n * n = n².
- **کاربرد**: الگوریتم‌های مرتب‌سازی غیربهینه مثل Bubble Sort یا Insertion Sort، یا بررسی جفت‌های عناصر در آرایه.

### 4. **O(log n) - پیچیدگی لگاریتمی (Logarithmic Time)**
- **توضیح**: زمان اجرا با افزایش ورودی خیلی کندتر رشد می‌کنه، چون ورودی در هر مرحله نصف می‌شه.
- **مثال**: جستجوی باینری (Binary Search) در آرایه مرتب‌شده.
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
```
- **چرا O(log n)؟** در هر مرحله، فضای جستجو نصف می‌شه (مثلاً 1000 به 500، به 250، و غیره)، پس تعداد عملیات به صورت لگاریتمی کاهش پیدا می‌کنه.
- **کاربرد**: جستجو در داده‌های مرتب‌شده، الگوریتم‌های تقسیم و غلبه (Divide and Conquer).

### 5. **O(n log n) - پیچیدگی خطی-لگاریتمی**
- **توضیح**: یه کم پیچیده‌تر از O(n) و خیلی بهتر از O(n²). معمولاً برای الگوریتم‌های مرتب‌سازی بهینه استفاده می‌شه.
- **مثال**: مرتب‌سازی سریع (Quick Sort).
```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  
  let pivot = arr[arr.length - 1];
  let left = [], right = [];
  
  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }
  
  return [...quickSort(left), pivot, ...quickSort(right)];
}
```
- **چرا O(n log n)؟** آرایه به بخش‌های کوچک‌تر تقسیم می‌شه (log n) و برای هر بخش، عملیات خطی (n) انجام می‌شه.
- **کاربرد**: الگوریتم‌های مرتب‌سازی بهینه مثل Quick Sort، Merge Sort.

### 6. **O(2^n) - پیچیدگی نمایی (Exponential Time)**
- **توضیح**: زمان اجرا با افزایش ورودی به صورت نمایی رشد می‌کنه. برای ورودی‌های بزرگ اصلاً مناسب نیست.
- **مثال**: محاسبه سری فیبوناچی به صورت بازگشتی (بدون بهینه‌سازی).
```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```
- **چرا O(2^n)؟** هر فراخوانی تابع دو فراخوانی دیگه تولید می‌کنه، که باعث رشد نمایی تعداد عملیات می‌شه.
- **کاربرد**: مسائل بازگشتی مثل مسئله فروشنده دوره‌گرد (Traveling Salesman) یا زیرمجموعه‌ها.

### نکات مهم برای یادگیری Big O:
1. **چطور پیچیدگی رو تشخیص بدیم؟**
   - **حلقه‌ها**: یه حلقه ساده روی n عنصر → O(n). حلقه داخل حلقه → O(n²).
   - **تقسیم و غلبه**: اگه ورودی در هر مرحله نصف بشه → O(log n).
   - **بازگشتی**: اگه هر فراخوانی چند فراخوانی جدید تولید کنه → احتمالاً O(2^n).
2. **چرا مهمه؟** Big O بهت کمک می‌کنه الگوریتمی انتخاب کنی که برای داده‌های بزرگ بهینه باشه.
3. **جاوااسکریپت و تک‌ریسمانی بودن**: چون جاوااسکریپت تک‌ریسمانیه، انتخاب الگوریتم‌های با پیچیدگی کم (مثل O(n) یا O(log n)) خیلی مهمه تا از کند شدن برنامه جلوگیری بشه.

### یه مثال ترکیبی:
فرض کن می‌خوای یه آرایه رو مرتب کنی و بعد یه عنصر رو توش پیدا کنی:
- مرتب‌سازی با Quick Sort: O(n log n)
- جستجو با Binary Search: O(log n)
- کل پیچیدگی: O(n log n) + O(log n) ≈ O(n log n)

### چطور تمرین کنی؟
1. کدهای ساده بنویس و سعی کن تعداد عملیات رو بشمری.
2. الگوریتم‌های معروف (مثل مرتب‌سازی، جستجو) رو پیاده‌سازی کن.
3. از ابزارهای آنلاین مثل LeetCode یا HackerRank برای حل مسئله استفاده کن و پیچیدگی زمانی رو تحلیل کن.

### خلاصه:
- **O(1)**: ثابت، مثل دسترسی به آرایه.
- **O(n)**: خطی، مثل جستجوی خطی.
- **O(n²)**: درجه دوم، مثل Bubble Sort.
- **O(log n)**: لگاریتمی، مثل Binary Search.
- **O(n log n)**: خطی-لگاریتمی، مثل Quick Sort.
- **O(2^n)**: نمایی، مثل فیبوناچی بازگشتی.


